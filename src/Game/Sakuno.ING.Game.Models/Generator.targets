<Project>
  <ItemGroup>
    <UpToDateCheckInput Include="$(MSBuildThisFileFullPath);@(Scaffold)" />
    <None Update="@(Scaffold)">
      <Generator>MSBuild:UpdateScaffold</Generator>
      <LastGenOutput>%(RelativeDir)%(Filename).g.cs</LastGenOutput>
    </None>
  </ItemGroup>

  <UsingTask TaskName="CalculatedScaffold" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Inputs ParameterType="System.String[]" Required="True" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
foreach (var infile in Inputs)
{
    string outfile = Path.ChangeExtension(infile, ".g.cs");
    Log.LogMessage("{0} -> {1}", infile, outfile);
    using (var input = File.OpenText(infile))
    using (var output = File.CreateText(outfile))
    {
        output.WriteLine(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------");
        var ns = input.ReadLine();
        while (true)
        {
            var line = input.ReadLine();
            if (string.IsNullOrEmpty(line))
                break;
            output.WriteLine("using " + line + ";");
        }
        output.WriteLine();
        output.Write("namespace ");
        output.WriteLine(ns);
        output.WriteLine("{");
        while (!input.EndOfStream)
        {
            var classes = input.ReadLine().Split(':');
            string thisClass = classes[0];
            string idClass = classes[1];
            string rawClass = classes[2];
            string ownerClass = classes[3];
            var props = new List<string>();
            var bindables = new List<string>();
            var localizables = new List<string>();
            bool hasName = false;
            while (true)
            {
                var line = input.ReadLine();
                int p = line.IndexOf(':');
                if (p < 0) break;
                switch (line.Substring(0, p))
                {
                    case "p":
                        props.Add(line.Substring(p + 1));
                        break;
                    case "b":
                        bindables.Add(line.Substring(p + 1));
                        break;
                    case "l":
                        localizables.Add(line.Substring(p + 1));
                        break;
                }
            }
            output.WriteLine("    public partial class " + thisClass + " : Calculated<" + idClass + ", " + rawClass + ">");
            output.WriteLine("    {");
            output.WriteLine("        public " + thisClass + "(" + idClass + " id, " + ownerClass + " owner) : base(id)");
            output.WriteLine("        {");
            output.WriteLine("            this.owner = owner;");
            var unlocalized = new List<string>();
            foreach (var l in localizables)
            {
                var prop = l.Split(' ');
                string propName = prop[0];
                string category = prop[1];
                if (propName == "Name")
                    hasName = true;
                output.WriteLine("            " + propName + "Translation = owner.Localization?.GetLocalized(\"" + category + "\", id.ToString());");
                if (prop.Length >= 3 && prop[2] == "u")
                {
                    output.WriteLine("            _unlocalized" + propName + " = owner.Localization?.GetUnlocalized(\"" + category + "\", id.ToString());");
                    unlocalized.Add(propName);
                }
            }
            output.WriteLine("            CreateDummy();");
            output.WriteLine("        }");
            output.WriteLine();
            output.WriteLine("        public " + thisClass + "(" + rawClass + " raw, " + ownerClass + " owner, DateTimeOffset timeStamp) : this(raw.Id, owner) => UpdateProps(raw, timeStamp);");
            output.WriteLine();
            output.WriteLine("        private readonly " + ownerClass + " owner;");
            var dummyList = new List<string>();
            foreach (var l in localizables)
            {
                var prop = l.Split(' ');
                output.WriteLine();
                string propName = prop[0];
                output.WriteLine("        public string " + propName + "Translation { get; }");
                if (prop.Length >= 3)
                    switch (prop[2])
                    {
                        case "-":
                            props.Add("string " + propName + " -");
                            break;
                        case "u":
                            props.Add("string " + propName);
                            output.WriteLine("        private readonly string _unlocalized" + propName + ";");
                            break;
                    }
            }
            foreach (var line in props)
            {
                var prop = line.Split(' ');
                string propName = prop[1];
                string propType = prop[0];
                string fieldName = "_" + char.ToLowerInvariant(propName[0]) + propName.Substring(1);
                if (prop.Length >= 3 && prop[2] == "-")
                    dummyList.Add(propName);
                output.WriteLine();
                output.WriteLine("        private " + propType + " " + fieldName + ";");
                output.WriteLine("        public " + propType + " " + propName);
                output.WriteLine("        {");
                output.WriteLine("            get => " + fieldName + ";");
                output.WriteLine("            internal set => Set(ref " + fieldName + ", value);");
                output.WriteLine("        }");
            }
            output.WriteLine();
            output.WriteLine("        public event Action<" + thisClass + ", " + rawClass + ", DateTimeOffset> Updating;");
            output.WriteLine("        public override void Update(" + rawClass + " raw, DateTimeOffset timeStamp)");
            output.WriteLine("        {");
            output.WriteLine("            Updating?.Invoke(this, raw, timeStamp);");
            output.WriteLine("            UpdateProps(raw, timeStamp);");
            output.WriteLine("        }");
            output.WriteLine();
            output.WriteLine("        private void UpdateProps(" + rawClass + " raw, DateTimeOffset timeStamp)");
            output.WriteLine("        {");
            output.WriteLine("            UpdationTime = timeStamp;");
            foreach (string prop in dummyList)
                output.WriteLine("            " + prop + " = raw." + prop + ";");
            foreach (string u in unlocalized)
                output.WriteLine("            " + u + " = _unlocalized" + u + " ?? raw." + u + ";");
            output.WriteLine();
            output.WriteLine("            UpdateCore(raw);");
            output.WriteLine("        }");
            output.WriteLine("        partial void UpdateCore(" + rawClass + " raw);");
            output.WriteLine("        partial void CreateDummy();");
            foreach (var b in bindables)
            {
                var prop = b.Split(' ');
                string name = prop[1];
                string type = prop[0];
                string field = char.ToLowerInvariant(name[0]) + name.Substring(1);
                output.WriteLine();
                output.WriteLine("        private readonly BindableSnapshotCollection<" + type + "> " + field + " = new BindableSnapshotCollection<" + type + ">();");
                output.WriteLine("        public IReadOnlyList<" + type +"> " + name + " => " + field + ";");
            }
            output.WriteLine();
            if (hasName)
                output.WriteLine("        public override string ToString() => $\"" + thisClass + " {Id}: {Name}\";");
            output.WriteLine("    }");
        }
        output.WriteLine("}");
        output.Flush();
    }
}
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="UpdateScaffold" Inputs="$(MSBuildThisFileFullPath);@(Scaffold)" Outputs="@(Scaffold->'%(RelativeDir)%(Filename).g.cs')" BeforeTargets="CoreCompile">
    <CalculatedScaffold Inputs="@(Scaffold)" />
  </Target>

  <PropertyGroup>
    <CoreCompileDependsOn>UpdateScaffold;$(CoreCompileDependsOn)</CoreCompileDependsOn>
  </PropertyGroup>
</Project>
